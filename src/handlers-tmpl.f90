! Copyright (C) 2011
! James Tappin

! This is free software; you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation; either version 3, or (at your option)
! any later version.

! This software is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.

! You should have received a copy of the GNU General Public License along with
! this program; see the files COPYING3 and COPYING.RUNTIME respectively.
! If not, see <http://www.gnu.org/licenses/>.

module handlers
  ! This module contains the signal handlers for RPNcalc, including those that
  ! are required by transient widgets generated by other handlers. 

  use iso_c_binding
  use gtk, only: gtk_statusbar_push, gtk_main_quit, gtk_entry_get_text_length, &
       & gtk_entry_get_text, gtk_editable_get_chars, gtk_editable_insert_text, &
       & gtk_editable_get_chars, gtk_editable_delete_text, &
       & gtk_about_dialog_new, gtk_about_dialog_set_program_name, &
       & gtk_about_dialog_set_license, gtk_about_dialog_set_comments, &
       & gtk_about_dialog_set_authors, gtk_main,&
       & gtk_window_set_transient_for, gtk_about_dialog_set_website, &
       & gtk_check_menu_item_get_active, gtk_widget_grab_focus, &
       & gtk_editable_set_position, gtk_combo_box_set_active, &
       & gtk_menu_item_set_label

  use g, only:  g_signal_stop_emission_by_name, g_utf8_validate

  use iso_fortran_env, only: error_unit

  use gtk_sup
  use gtk_hl
  use widgets
  use utils

  implicit none

  ! Constants (these are used both in main and some handlers)
  character, parameter :: linefeed=char(10)
  real(kind=c_double), parameter :: pi = 3.1415926535897932384626433832795029_c_double
  real(kind=c_double), parameter :: dtor = pi/180._c_double

contains

  subroutine my_destroy (widget, gdata) bind(c)
    ! Destroy the heirarchy.

    use iso_c_binding, only: c_ptr
    type(c_ptr), value :: widget, gdata
    call gtk_widget_destroy(win)
    call gtk_main_quit ()
  end subroutine my_destroy

  subroutine enter_value(widget, gdata) bind(c)
    ! Enter key or <Enter> in the input window, transfer the value to the stack
    type(c_ptr), value :: widget, gdata

    real(kind=c_double) :: val
    logical :: status
    integer(kind=c_int) :: mid

    mid = gtk_statusbar_push(fstatus, 0, c_null_char)
    call read_entry(val, status, push=.true.)
    if (.not. status) return
    call gtk_entry_set_text(fentry, c_null_char)
    call set_result(val)
  end subroutine enter_value

  subroutine char_entered(widget, ctext, nchars, ppos, gdata) bind(c)
    ! A few basic sanity checks on numeric entry
    type(c_ptr), value :: widget, ctext, ppos, gdata
    integer(kind=c_int), value :: nchars

    character(len=40) :: itext, etext, otext, wtext
    integer(kind=c_int) :: nentry
    type(c_ptr) :: cetext
    integer(kind=c_int), pointer :: ipos
    integer :: i, j, iloc
    integer(kind=c_int) :: mid
    logical :: dflag, eflag, svalid
    integer(kind=c_int), target :: opcode

    integer, parameter :: err_ok = 0
    integer, parameter :: err_invalid = 1
    integer, parameter :: err_exponent = 2
    integer, parameter :: err_decimal = 4
    integer :: error_code

    call convert_c_string(ctext, nchars, itext)
    call c_f_pointer(ppos, ipos)
    if (ipos == 0) itext=adjustl(itext)

    nentry = gtk_entry_get_text_length(widget)
    cetext = gtk_entry_get_text(widget)
    call convert_c_string(cetext, nentry, etext)

    eflag=.false.
    dflag=.false.

    j=1
    opcode=OP_NONE
    error_code = err_ok
    do i = 1, nchars
       select case(itext(i:i))
       case('0':'9') ! A number, always OK
          otext(j:j) = itext(i:i)
          j = j+1

       case('.') ! A decimal point (OK if there's not already one present
          ! and it's not after an exponent
          if (decimal_present) then
             error_code = ior(error_code, err_decimal)
             cycle
          end if
          if (exponent_present) then
             if (i > 1) then
                if (scan(itext(:i-1), "EeDd") > 0) then
                   error_code = ior(error_code, err_decimal)
                   cycle
                end if
             end if
             if (ipos > 0) then
                if (scan(etext(:ipos),"EeDd") > 0) then
                   error_code = ior(error_code, err_decimal)
                   cycle
                end if
             end if
          end if
          otext(j:j) = itext(i:i)
          j = j+1
          dflag = .true.

       case("E","D","e","d") ! An exponent (OK if there isn't already one
          ! and it's not before a decimal, and there's at least 1 number
          ! before it)
          if (exponent_present) then
             error_code = ior(error_code, err_exponent)
             cycle
          end if
          if (decimal_present) then
             if (i < len_trim(itext)) then
                if (index(itext(i+1:),'.') > 0) then
                   error_code = ior(error_code, err_exponent)
                   cycle
                end if
             end if
             if (ipos < nchars-1) then
                if (index(etext(ipos+1:),'.') > 0) then
                   error_code = ior(error_code, err_exponent)
                   cycle
                end if
             end if
          end if
          if (scan(etext(:ipos),"0123456789") == 0 .and. &
               & scan(itext(:i),"0123456789") == 0) then
             error_code = ior(error_code, err_exponent)
             cycle
          end if
          otext(j:j) = itext(i:i)
          j = j+1
          eflag = .true.

       case("+","-") ! A sign (OK at the start or immediately after
          ! an exponent, or at the very end when it's an operator.
          svalid=.true.
          if (i > 1) then
             if (scan(itext(i-1:i-1), "EeDd") == 0) svalid=.false.
          else if (ipos == 0) then
             if (scan(etext(1:1), "+-") /= 0) svalid=.false.
          end if
          if (ipos > 0) then
             if (scan(etext(ipos:ipos), "EeDd") == 0) svalid=.false.
             if (scan(etext(ipos+1:), "+-") /= 0) svalid=.false.
          end if
          if (svalid) then
             otext(j:j) = itext(i:i)
             j = j+1
          else if (i == nchars .and. ipos == nentry .and. &
               & nchars+nentry > 1) then
             if (itext(i:i) == '+') then
                opcode = OP_PLUS
             else
                opcode = OP_MINUS
             endif
             exit
          end if

       case("*","/","^") ! Operators other than + & -
          if (i == nchars .and. ipos == nentry) then
             select case(itext(i:i))
             case("*")
                opcode = OP_TIMES
             case("/")
                opcode = OP_DIVIDE
             case("^")
                opcode = OP_POWER
             end select
             exit
          else
             cycle
          end if
 
       case default  ! Anything else is invalid
          error_code = ior(error_code, err_invalid)
       end select
    end do

    if (j <= nchars) then ! We had to exclude some chars otherwise let the
       ! default handler do it.
       select case (error_code)
       case (err_invalid)
          mid = gtk_statusbar_push(fstatus, 0, &
               & "Entered text includes invalid characters -- excluded"// &
               & c_null_char)
       case (err_exponent)
          mid = gtk_statusbar_push(fstatus, 0, &
               & "Entered text includes misplaced exponent -- ignored"// &
               & c_null_char)
       case (err_decimal) 
          mid = gtk_statusbar_push(fstatus, 0, &
               & "Entered text includes misplaced decimal -- ignored"// &
               & c_null_char)
       case default   ! More than one of the above
          mid = gtk_statusbar_push(fstatus, 0, &
               & "Entered text includes errors -- ignored"// &
               & c_null_char)
       end select

       if (j > 0) then
          if (ipos > 0) then
             wtext = etext(:ipos)//otext(:j-1)
          else
             wtext = otext(:j-1)
          endif
          if (ipos < nentry-1) then
             wtext = trim(wtext)//trim(etext(ipos+1:))
          end if
          call gtk_entry_set_text(widget, trim(wtext)//c_null_char)
       endif
       if (dflag) decimal_present = .true.
       if (eflag) exponent_present = .true.
       if (opcode /= OP_NONE) call oppress(C_NULL_PTR, c_loc(opcode))
       ipos = ipos+j-1

       call g_signal_stop_emission_by_name(widget, "insert-text")
    else
       if (dflag) decimal_present = .true.
       if (eflag) exponent_present = .true.
    end if
  end subroutine char_entered

  subroutine char_deleted(widget, istart, iend, gdata) bind(c)
    ! When characters are deleted, check what's deleted and clear
    ! flags if needed
    type(c_ptr), value :: widget, gdata
    integer(kind=c_int), value :: istart, iend

    type(c_ptr) :: cetext
    integer(kind=c_int) :: nchars
    character(len=40) :: etext
    integer :: iloc, ilocs

    nchars = gtk_entry_get_text_length(widget)
    cetext = gtk_entry_get_text(widget)

    if (iend < 0) iend = nchars-1
    call convert_c_string(cetext, nchars, etext)

    ! Was there an exponent marker in the deleted segment?
    iloc = scan(etext(istart+1:iend+1), "EeDd")
    if (iloc > 0) exponent_present = .false.

    iloc = index(etext(istart+1:iend+1), '.')
    if (iloc > 0) decimal_present = .false.

  end subroutine char_deleted

  subroutine numpress(widget, gdata) bind(c)
    ! Keypad number entry -- gdata will be a pointer to the number
    type(c_ptr), value :: widget, gdata

    character, pointer :: fdata
    integer(kind=c_int) :: mid

    mid = gtk_statusbar_push(fstatus, 0, c_null_char)
    if (c_associated(gdata)) then
       call c_f_pointer(gdata, fdata)
       call append_char_entry(fdata//c_null_char)
    end if

    call gtk_widget_grab_focus(fentry)
    call gtk_editable_set_position(fentry, -1)   ! Put cursor at end


  end subroutine numpress

  subroutine dppress(widget, gdata) bind(c)
    ! Keypad decimal point
    type(c_ptr), value :: widget, gdata

    integer(kind=c_int) :: mid

    if (decimal_present .or. exponent_present) then
       mid = gtk_statusbar_push(fstatus, 0, &
            & "Decimal point not permitted here"//c_null_char)
    else
       call append_char_entry("."//c_null_char)
       decimal_present = .TRUE.
    end if

    call gtk_widget_grab_focus(fentry)
    call gtk_editable_set_position(fentry, -1)   ! Put cursor at end

  end subroutine dppress

  subroutine chspress(widget, gdata) bind(c)
    ! The change sign key (+/-)
    type(c_ptr), value :: widget, gdata

    type(c_ptr) :: ctext
    character :: ftext
    integer(kind=c_int), target :: pos
    character(len=40) :: alltext
    integer(kind=c_int) :: nchars, mid
    integer :: idx
    real(kind=c_double) :: x
    logical :: status

    mid = gtk_statusbar_push(fstatus, 0, c_null_char)
    nchars = int(gtk_entry_get_text_length(fentry), c_int)
    if (exponent_present) then
       ctext = gtk_entry_get_text(fentry)
       call convert_c_string(ctext, nchars, alltext)
       idx = max(index(alltext, 'E'), index(alltext,'e'), &
            & index(alltext, 'D'), index(alltext, 'd'))
       if (idx == 0) then
          mid = gtk_statusbar_push(fstatus, 0, "D'Oh"//c_null_char)
       else
          idx=idx+1
          select case(alltext(idx:idx))
          case ('+')
             alltext(idx:idx) = '-'
          case('-')
             alltext = alltext(:idx-1)//alltext(idx+1:)
          case default
             alltext = alltext(:idx-1)//'-'//alltext(idx:)
          end select
          call gtk_entry_set_text(fentry, trim(alltext)//c_null_char)
       end if
    else if (nchars > 0) then
       ctext = gtk_editable_get_chars(fentry, 0, 1)
       call convert_c_string(ctext, 1, ftext)
       pos = 0
       select case(ftext)
       case ('+')
          call gtk_editable_delete_text(fentry, 0, 1)
          call gtk_editable_insert_text(fentry, '-'//c_null_char, 1, c_loc(pos))
       case ('-')
          call gtk_editable_delete_text(fentry, 0, 1)
       case default  ! no sign present
          call gtk_editable_insert_text(fentry, '-'//c_null_char, 1, c_loc(pos))
       end select
    else
       call set_result()
       call pop_stack(x, status)
       if (status) then
          x = -x
          call push_stack(x)
       end if
    end if

    call gtk_widget_grab_focus(fentry)
    call gtk_editable_set_position(fentry, -1)   ! Put cursor at end

  end subroutine chspress

  subroutine eepress(widget, gdata) bind(c)
    ! Exponent entry key (EE)
    type(c_ptr), value :: widget, gdata

    integer(kind=c_int) :: mid, nchars
    integer(kind=c_int), target :: pos

    if (exponent_present) then
       mid = gtk_statusbar_push(fstatus, 0, &
            & "Exponent already present"//c_null_char)
    else
       nchars = int(gtk_entry_get_text_length(fentry), c_int)
       if (nchars == 0) then
          mid = gtk_statusbar_push(fstatus, 0, &
               & "Must have a mantissa before an exponent."//c_null_char)
       else
          pos = nchars
          call gtk_editable_insert_text(fentry, 'E'//c_null_char, 1, c_loc(pos))
          exponent_present = .true.
       end if
    end if

    call gtk_widget_grab_focus(fentry)
    call gtk_editable_set_position(fentry, -1)   ! Put cursor at end

  end subroutine eepress

  subroutine pipress(widget, gdata) bind(c)
    ! The PI key
    type(c_ptr), value :: widget, gdata

    call push_stack(pi)
    call gtk_entry_set_text(fentry, c_null_char)

    call gtk_widget_grab_focus(fentry)
    call gtk_editable_set_position(fentry, -1)   ! Put cursor at end

  end subroutine pipress

  subroutine add_const(widget, gdata) bind(c)
    ! Physics constants
    type(c_ptr), value :: widget, gdata

    real(kind=c_double), pointer :: cval

    call c_f_pointer(gdata, cval)

    call push_stack(cval)
    call gtk_entry_set_text(fentry, c_null_char)

    call gtk_widget_grab_focus(fentry)
    call gtk_editable_set_position(fentry, -1)   ! Put cursor at end

  end subroutine add_const

  subroutine delpress(widget, gdata) bind(c)
    ! The del key -- delete the last character in the entry window
    type(c_ptr), value :: widget, gdata

    integer(kind=c_int) :: nchars
    character :: last
    type(c_ptr) :: clast

    nchars = int(gtk_entry_get_text_length(fentry), c_int)
    if (nchars == 0) return

    clast = gtk_editable_get_chars(fentry, nchars-1, nchars)
    call convert_c_string(clast, 1, last)
    call gtk_editable_delete_text(fentry, nchars-1, nchars)

    select case(last)
    case('.')
       decimal_present = .false.
    case('E','e','D','d')
       exponent_present = .false.
    end select


    call gtk_widget_grab_focus(fentry)
    call gtk_editable_set_position(fentry, -1)   ! Put cursor at end

  end subroutine delpress

  subroutine duppress(widget, gdata) bind(c)
    ! The dup key. If there is a value in the entry window, copy it to the
    ! stack; if not, duplicate the top entry on the stack.
    type(c_ptr), value :: widget, gdata

    integer(kind=c_int) :: nchars, mid
    real(kind=c_double) :: val
    logical :: status

    mid = gtk_statusbar_push(fstatus, 0, c_null_char)
    nchars = int(gtk_entry_get_text_length(fentry), c_int)

    call gtk_widget_grab_focus(fentry)
    call gtk_editable_set_position(fentry, -1)   ! Put cursor at end

    if (nchars == 0) then
       call pop_stack(val, status, readonly=.TRUE.)
       if (.not. status) return
       call push_stack(val)
    else
       call read_entry(val, status, push=.true.)
       if (.not. status) return
    end if
    call set_result(val)
  end subroutine duppress

  subroutine oppress(widget, gdata) bind(c)
    ! One of the operators (including ATAN2). Gdata is a pointer
    ! to the operation code

    type(c_ptr), value :: widget, gdata

    integer(kind=c_int), pointer :: opcode
    integer(kind=c_int) :: mid, nchars
    real(kind=c_double) :: x, y, z
    logical :: status


    call gtk_widget_grab_focus(fentry)
    call gtk_editable_set_position(fentry, -1)   ! Put cursor at end


    call set_result()
    nchars = int(gtk_entry_get_text_length(fentry), c_int)
    if (nchars > 0) then  ! Have a value in the entry window (will be X)
       call read_entry(x, status, push=.false.)
       if (.not. status) return

       call pop_stack(y, status)
       if (.not. status) return

       call gtk_entry_set_text(fentry, c_null_char)
    else
       call pop_stack(x, status)
       if (.not. status) return
       call pop_stack(y, status)
       if (.not. status) then
          call push_stack(x, show_result=.false.)
          return
       end if
    end if

    call c_f_pointer(gdata, opcode)
    select case(opcode)
    case(OP_PLUS)
       z = y+x
    case (OP_MINUS)
       z = y-x
    case (OP_TIMES)
       z = y*x
    case (OP_DIVIDE)
       z = y/x
    case (OP_POWER)
       ! If the inverse flag is set and the operation was initiated by
       ! the power button (rather than the ^ keystroke) take the root
       if (isinv .and. c_associated(widget)) x = 1._c_double/x
       if (x == aint(x)) then  ! integer power safe for all signs
          z = y**int(x)

       else if (y < 0._c_double) then ! real power of a negative value
          ! (not allowed)
          mid = gtk_statusbar_push(fstatus, 0, &
               & "Cannot raise a negative value to a real power"//c_null_char)
          call push_stack(y, show_result=.false.)
          call push_stack(x, show_result=.false.)
          return
       else
          z = y**x
       end if
       if (isinv .and. c_associated(widget)) then ! Only power is
          !  affected by inverse flag
          call gtk_toggle_button_set_active(karc, FALSE)
          isinv = .FALSE.
          call set_labels
       end if
    case(FUN_ATAN2)
       z = atan2(y, x)
       select case(trigunit)
       case(1)
          z = z * 180._c_double/pi
       case(2)
          z = z * 200._c_double/pi
       case(0)
       end select
    end select
    call push_stack(z)
    call set_result(z)
    mid = gtk_statusbar_push(fstatus, 0, c_null_char)
  end subroutine oppress

  subroutine cepress(widget, gdata) bind(c)
    ! Clear entry: Delete the entry window or the top element of the stack
    type(c_ptr), value :: widget, gdata

    integer(kind=c_int16_t) :: nchars
    real(kind=c_double) :: xjunk
    logical :: status
    integer(kind=c_int) :: mid

    nchars = gtk_entry_get_text_length(fentry)
    if (nchars > 0) then
       call gtk_entry_set_text(fentry, c_null_char)
       call clear_entry_flags
    else
       call pop_stack(xjunk, status)
    end if
    call set_result()
    mid = gtk_statusbar_push(fstatus, 0, c_null_char)

    call gtk_widget_grab_focus(fentry)
    call gtk_editable_set_position(fentry, -1)   ! Put cursor at end

  end subroutine cepress

  subroutine capress(widget, gdata) bind(c)
    ! Clear all
    type(c_ptr), value :: widget, gdata

    integer(kind=c_int16_t) :: nchars
    integer(kind=c_int) :: mid

    call set_result()

    nchars = gtk_entry_get_text_length(fentry)
    if (nchars > 0) then
       call gtk_entry_set_text(fentry, c_null_char)
       call clear_entry_flags
    endif

    call hl_gtk_listn_rem(fstack)
    mid = gtk_statusbar_push(fstatus, 0, c_null_char)
    if (dynamic_stats) call stack_stats(0._c_double, clear=.true.)

    call gtk_widget_grab_focus(fentry)
    call gtk_editable_set_position(fentry, -1)   ! Put cursor at end


  end subroutine capress

  subroutine uppress(widget, gdata) bind(c)
    ! Move the current selection up the stack
    type(c_ptr), value :: widget, gdata

    integer(kind=c_int) :: nchars, mid
    type(c_ptr) :: ctext
    character(len=40) :: ftext
    character(len=80) :: iom
    integer :: ios
    real(kind=c_double) :: x, y
    logical :: status, sflag

    mid = gtk_statusbar_push(fstatus, 0, c_null_char)
    sflag = .true.

    call gtk_widget_grab_focus(fentry)
    call gtk_editable_set_position(fentry, -1)   ! Put cursor at end

    if (stack_selected <= 0) then ! top element or none
       ! (swap with the entry box)
       nchars = int(gtk_entry_get_text_length(fentry), c_int)
       if (nchars == 0) then ! just pop the top of the stack to the box
          call pop_stack(x, status)
          sflag=.false.
          if (.not. status) return
          write(ftext,*) x
          call gtk_entry_set_text(fentry, trim(adjustl(ftext))//c_null_char)
       else
          call read_entry(x, status, push=.false.)
          if (.not. status) return
          call pop_stack(y, status)
          if (.not. status) return
          call push_stack(x)
          write(ftext,*) y
          call gtk_entry_set_text(fentry, trim(adjustl(ftext))//c_null_char)
       end if
       call hl_gtk_listn_set_selection(fstack)
    else
       call hl_gtk_listn_swap_rows(fstack, stack_selected, stack_selected-1)
       stack_selected = stack_selected-1
    end if
    if (sflag) then
       call pop_stack(x, status, readonly=.true.)
       if (status) call set_result(x)
    end if
  end subroutine uppress

  subroutine downpress(widget, gdata) bind(c)
    ! Move the current selection down the stack
    type(c_ptr), value :: widget, gdata

    integer(kind=c_int) :: nchars, mid
    type(c_ptr) :: ctext
    character(len=40) :: ftext
    character(len=80) :: iom
    integer :: ios
    real(kind=c_double) :: x, y
    integer(kind=c_int) :: isel, nrows
    logical :: status

    mid = gtk_statusbar_push(fstatus, 0, c_null_char)

    call gtk_widget_grab_focus(fentry)
    call gtk_editable_set_position(fentry, -1)   ! Put cursor at end

    if (stack_selected < 0) then ! no selection
       nchars = int(gtk_entry_get_text_length(fentry), c_int)
       if (nchars == 0) return ! No action of entry is empty

       ctext = gtk_entry_get_text(fentry)
       call convert_c_string(ctext, nchars, ftext)
       read(ftext, *, iostat=ios, iomsg=iom) x
       if (ios /= 0) then
          mid = gtk_statusbar_push(fstatus, 0, trim(iom)//c_null_char)
          return
       end if
       call pop_stack(y, status)
       if (.not. status) return
       call push_stack(x)
       write(ftext,*) y
       call gtk_entry_set_text(fentry, trim(adjustl(ftext))//c_null_char)
       call hl_gtk_listn_set_selection(fstack)
    else
       nrows = hl_gtk_listn_get_n_rows(fstack)
       if (nrows <= 1) return
       isel = min(stack_selected, nrows-2)
       call hl_gtk_listn_swap_rows(fstack, isel, isel+1)
       if (isel == stack_selected) then
          stack_selected = stack_selected+1
       else
          stack_selected = stack_selected-1
       end if
    end if
    call pop_stack(x, status, readonly=.true.)
    if (status) call set_result(x)
  end subroutine downpress

  subroutine rollpress(widget, gdata) bind(c)
    type(c_ptr), value :: widget, gdata

    real(kind=c_double) :: x
    logical :: status

    integer(kind=c_int), dimension(:), allocatable :: idx
    integer :: i, nshift
    integer(kind=c_int) :: nrows,mid

    mid = gtk_statusbar_push(fstatus, 0, c_null_char)
    nrows = hl_gtk_listn_get_n_rows(fstack)
    if (nrows <= 1) return  ! Empty or 1 row can't roll

    allocate(idx(nrows))
    if (isinv) then
       nshift=1
    else
       nshift=-1
    end if
    idx = (/ (i-1, i=1,nrows) /)
    idx = cshift(idx, nshift)
    call hl_gtk_listn_reorder(fstack, idx)

    call pop_stack(x, status, readonly=.true.)
    if (status) call set_result(x)

    call gtk_widget_grab_focus(fentry)
    call gtk_editable_set_position(fentry, -1)   ! Put cursor at end

    if (isinv) then
       call gtk_toggle_button_set_active(karc, FALSE)
       isinv=.false.
       call set_labels
    end if
  end subroutine rollpress

  subroutine funpress(widget, gdata) bind(c)
    ! The 1-argument functions. GDATA is a pointer to the
    ! function identifier.
    type(c_ptr), value :: widget, gdata

    real(kind=c_double) :: x, z, acf
    integer(kind=c_int), pointer :: funcode
    integer(kind=c_int) :: nchars, mid
    logical :: status
    integer :: i


    call gtk_widget_grab_focus(fentry)
    call gtk_editable_set_position(fentry, -1)   ! Put cursor at end

    call set_result()
    nchars = int(gtk_entry_get_text_length(fentry), c_int)
    if (nchars > 0) then
       call read_entry(x, status, push=.false.)
       if (.not. status) return
       call gtk_entry_set_text(fentry, c_null_char)
    else
       call pop_stack(x, status)
       if (.not. status) return
    end if

    select case(trigunit)
    case(0)      ! Radians
       acf = 1._c_double
    case(1)      ! Degrees
       acf = pi/180._c_double
    case(2)      ! Grads
       acf = pi/200._c_double
    end select

    call c_f_pointer(gdata, funcode)

    select case(funcode)
    case(FUN_SIN)
       if (isinv) then
          if (abs(x) > 1._c_double) then
             mid = gtk_statusbar_push(fstatus, 0, &
                  & "Asin argument out of range"//c_null_char)
             call push_stack(x, show_result=.false.)
             return
          end if
          z = asin(x)/acf
       else
          z = sin(x*acf)
       end if
    case(FUN_COS)
       if (isinv) then
          if (abs(x) > 1._c_double) then
             mid = gtk_statusbar_push(fstatus, 0, &
                  & "Acos argument out of range"//c_null_char)
             call push_stack(x, show_result=.false.)
             return
          end if
          z = acos(x)/acf
       else
          z = cos(x*acf)
       end if
    case(FUN_TAN)
       if (isinv) then
          z = atan(x)/acf
       else
          z = tan(x*acf)
       end if
    case(FUN_LN)
       if (isinv) then
          z = exp(x)
       else
          if (x <= 0._c_double) then
             mid = gtk_statusbar_push(fstatus, 0, &
                  & "Ln argument out of range"//c_null_char)
             call push_stack(x, show_result=.false.)
             return
          end if
          z = log(x)
       end if
    case(FUN_SQRT)
       if (isinv) then
          z = x**2
       else
          if (x <= 0._c_double) then
             mid = gtk_statusbar_push(fstatus, 0, &
                  & "Sqrt argument out of range"//c_null_char)
             call push_stack(x, show_result=.false.)
             return
          end if
          z = sqrt(x)
       end if
    case(FUN_SINH)
       if (isinv) then
          z = asinh(x)
       else
          z = sinh(x)
       end if
    case(FUN_COSH)
       if (isinv) then
          if (x < 1._c_double) then
             mid = gtk_statusbar_push(fstatus, 0, &
                  & "Acosh argument out of range"//c_null_char)
             call push_stack(x, show_result=.false.)
             return
          end if
          z = acosh(x)
       else
          z = cosh(x)
       end if
    case(FUN_TANH)
       if (isinv) then
          if (abs(x) > 1._c_double) then
             mid = gtk_statusbar_push(fstatus, 0, &
                  & "Atanh argument out of range"//c_null_char)
             call push_stack(x, show_result=.false.)
             return
          end if
          z = atanh(x)
       else
          z = tanh(x)
       end if
    case(FUN_LOG10)
       if (isinv) then
          z = 10._c_double ** x
       else
          if (x <= 0._c_double) then
             mid = gtk_statusbar_push(fstatus, 0, &
                  & "Log10 argument out of range"//c_null_char)
             call push_stack(x, show_result=.false.)
             return
          end if
          z = log10(x)
       end if
    case(FUN_INV)
       if (x == 0._c_double) then
          mid = gtk_statusbar_push(fstatus, 0, &
               & "Zero argument for 1/X in not permitted"//c_null_char)
          call push_stack(x, show_result=.false.)
          return
       end if
       z = 1._c_double / x
    case(FUN_ABS)
       z = abs(x)
    case(FUN_INT)
       z = aint(x)
    case(FUN_FRAC)
       z = x - aint(x)
    case(FUN_FACTORIAL)
       if (x == aint(x) .and. x >= 0) then
          z = 1._c_double
          do i = 2, int(x)
             z = z*real(i, c_double)
          end do
       else
          mid = gtk_statusbar_push(fstatus, 0, &
               & "Factorial argument out of range or not an integer"//c_null_char)
          call push_stack(x, show_result=.false.)
          return
       end if
    end select
    call push_stack(z)
    mid = gtk_statusbar_push(fstatus, 0, c_null_char)
    if (isinv) then
       call gtk_toggle_button_set_active(karc, FALSE)
       isinv = .FALSE.
       call set_labels
    end if
  end subroutine funpress

  subroutine hmspress(widget, gdata) bind(c)
    ! Display the entry box or top of stack in HMS format
    type(c_ptr), value :: widget, gdata

    integer(kind=c_int) :: nchars, mid
    logical :: status
    real(kind=c_double) :: val


    call gtk_widget_grab_focus(fentry)
    call gtk_editable_set_position(fentry, -1)   ! Put cursor at end

    nchars=int(gtk_entry_get_text_length(fentry), c_int)
    if (nchars > 0) then
       call read_entry(val, status,push=.false.)
       if (.not. status) return
    else
       call pop_stack(val, status, readonly=.TRUE.)
       if (.not. status) return
    end if
    call show_hms(val, fresult)
    mid = gtk_statusbar_push(fstatus, 0, c_null_char)
  end subroutine hmspress

  subroutine invtoggle(widget, gdata) bind(c)
    ! Toggle inverse functions
    type(c_ptr), value :: widget, gdata

    isinv = (gtk_toggle_button_get_active(widget) == TRUE)
    call set_labels

    call gtk_widget_grab_focus(fentry)
    call gtk_editable_set_position(fentry, -1)   ! Put cursor at end

  end subroutine invtoggle

  subroutine set_trigunit(widget, gdata) bind(c)
    ! Select trig units
    type(c_ptr), value :: widget, gdata

    trigunit = hl_gtk_radio_group_get_select(rdgrp)

    call gtk_widget_grab_focus(fentry)
    call gtk_editable_set_position(fentry, -1)   ! Put cursor at end

  end subroutine set_trigunit

  subroutine stacksel(widget, gdata) bind(c)
    ! Select an item on the stack
    type(c_ptr), value :: widget, gdata

    integer(kind=c_int) :: count
    integer(kind=c_int), dimension(:), allocatable :: sellist

    count = hl_gtk_listn_get_selections(fstack, sellist)
    if (count == 0) then
       stack_selected = -1
    else
       stack_selected = sellist(1)
       deallocate(sellist)
    end if

    call gtk_widget_grab_focus(fentry)
    call gtk_editable_set_position(fentry, -1)   ! Put cursor at end

  end subroutine stacksel

  subroutine mempress(widget, gdata) bind(c)
    ! A memory key.
    type(c_ptr), value :: widget, gdata

    integer(kind=c_int), pointer :: memop
    integer(kind=c_int) :: midx
    real(kind=c_double) :: x, y
    integer(kind=c_int) :: nchars, mid
    logical :: status, need_x, entry_index

    call c_f_pointer(gdata, memop)

    need_x = .not. (memop == MEM_RCL .or. memop == MEM_CLR .or. &
         & memop == MEM_CLA)

    nchars = gtk_entry_get_text_length(fentry)


    call gtk_widget_grab_focus(fentry)
    call gtk_editable_set_position(fentry, -1)   ! Put cursor at end


    if (memop /= MEM_CLA) then
       if (mem_selected >= 0) then ! A register is selected by the list
          midx = mem_selected
          if (need_x) then
             if (nchars > 0) then
                call read_entry(x, status, push=.false.)
             else
                call pop_stack(x, status, readonly=.true.)
             end if
             if (.not. status) return
          end if
          entry_index=.false.
       else
          if (nchars == 0) then
             mid = gtk_statusbar_push(fstatus, 0, &
                  & "No content in entry and no register selected"//c_null_char)
             return
          end if
          call read_entry(midx, status)
          if (.not. status .or. midx < 0 .or. midx > maxreg) then
             mid = gtk_statusbar_push(fstatus, 0, &
                  & "Entry field is not a valid register"//c_null_char)
             return
          end if
          entry_index=.true.
          if (need_x) then
             call pop_stack(x, status, readonly=.true.)
             if (.not. status) return
          end if
       end if
    end if

    select case(memop)
    case(MEM_STO)
       call hl_gtk_listn_set_cell(fmemory, midx, 1, dvalue=x)
    case(MEM_RCL)
       call hl_gtk_listn_get_cell(fmemory, midx, 1, dvalue=y)
       call push_stack(y)
    case(MEM_PLUS)
       call hl_gtk_listn_get_cell(fmemory, midx, 1, dvalue=y)
       call hl_gtk_listn_set_cell(fmemory, midx, 1, dvalue=y+x)
    case(MEM_MINUS)
       call hl_gtk_listn_get_cell(fmemory, midx, 1, dvalue=y)
       call hl_gtk_listn_set_cell(fmemory, midx, 1, dvalue=y-x)
    case(MEM_CLR)
       call hl_gtk_listn_set_cell(fmemory, midx, 1, dvalue=0._c_double)
    case(MEM_CLA)
       do midx = 0, maxreg
          call hl_gtk_listn_set_cell(fmemory, midx, 1, dvalue=0._c_double)
       end do
    end select

    call hl_gtk_listn_set_selection(fmemory)
    mem_selected = -1
    if (entry_index) call gtk_entry_set_text(fentry, c_null_char)
    mid = gtk_statusbar_push(fstatus, 0, c_null_char)
  end subroutine mempress

  subroutine memsel(widget, gdata) bind(c)
    ! A selection in the registers list
    type(c_ptr), value :: widget, gdata

    integer(kind=c_int) :: count
    integer(kind=c_int), dimension(:), allocatable :: sellist

    count = hl_gtk_listn_get_selections(fmemory, sellist)
    if (count == 0) then
       mem_selected = -1
    else
       mem_selected = sellist(1)
       deallocate(sellist)
    end if

    call gtk_widget_grab_focus(fentry)
    call gtk_editable_set_position(fentry, -1)   ! Put cursor at end

  end subroutine memsel

  subroutine save_values(widget, gdata) bind(c)
    ! Save the stack and registers
    type(c_ptr), value :: widget, gdata

    integer(kind=c_int) :: response
    character(len=256), dimension(:), allocatable :: file

    response = hl_gtk_file_chooser_show(file, confirm_overwrite=TRUE, &
         & parent=win, filter=(/"*.rpn"/), &
         & filter_name=(/"RPN save files"/), edit_filters=TRUE)


    call gtk_widget_grab_focus(fentry)
    call gtk_editable_set_position(fentry, -1)   ! Put cursor at end

    if (response == FALSE) return

    call save_all(file(1))
    deallocate(file)

  end subroutine save_values

  subroutine restore_values(widget, gdata) bind(c)
    ! restore the stack and registers
    type(c_ptr), value :: widget, gdata

    integer(kind=c_int) :: response
    character(len=256), dimension(:), allocatable :: file

    response = hl_gtk_file_chooser_show(file, create=FALSE, &
         & parent=win, filter=(/"*.rpn"/), &
         & filter_name=(/"RPN save files"/), edit_filters=TRUE)


    call gtk_widget_grab_focus(fentry)
    call gtk_editable_set_position(fentry, -1)   ! Put cursor at end

    if (response == FALSE) return

    call restore_all(file(1))

    deallocate(file)

  end subroutine restore_values

  subroutine show_help(widget, gdata) bind(c)
    ! Display help text
    type(c_ptr), value :: widget, gdata

    character(len=*), parameter :: textfile="@TEXTFILE@"
    character(len=*), parameter :: pdffile="@PDFFILE@"
    type(c_ptr) :: hscroll, hview, hquit, hbox
    character(kind=c_char), dimension(:), allocatable, save :: text
    integer :: unit, iostat, textlen
    character(len=80) :: iomsg
    integer(kind=c_int) :: isvalid
    type(c_ptr) :: end_point
    character(kind=c_char), pointer :: end_char
    character(len=256) :: pdfviewer
    integer :: vstatus

    call get_environment_variable('RPNCALC_VIEWER', value=pdfviewer, &
         & status=vstatus)

    if (vstatus == 0) then
       call execute_command_line(trim(pdfviewer)//' '//pdffile, wait=.false.)
    else
       if (.not. allocated(text)) then
          ! Note that the easiest way to read a whole file into an array
          ! of CHAR*1 is to open it as an unformatted stream.
          open(newunit=unit, file=textfile, access='stream', action='read', &
               & iostat=iostat, iomsg=iomsg, form="unformatted")
          if (iostat /= 0) then
             write(error_unit, *) "rpncalc: Failed to open help file: ", &
                  & trim(textfile)
             write(error_unit, *) "Reason: ", trim(iomsg)
             return
          end if
          inquire(unit, size=textlen)
          allocate(text(textlen))
          read(unit, iostat=iostat, iomsg=iomsg) text
          if (iostat /= 0) then
             write(error_unit, *) "rpncalc: Failed to read help file: ", &
                  & trim(textfile)
             write(error_unit, *) "Reason: ", trim(iomsg)
             return
          end if
          close(unit)
       end if

       help_window = hl_gtk_window_new("RPN Calculator"//c_null_char, &
            & deletable=FALSE, above=TRUE, parent=win)

       hbox = hl_gtk_box_new()
       call gtk_container_add(help_window, hbox)

       hview = hl_gtk_text_view_new(hscroll, editable=FALSE, &
            & ssize=(/700, 600/), initial_text = text)
       call hl_gtk_box_pack(hbox, hscroll)

       hquit = hl_gtk_button_new("Dismiss"//c_null_char, &
            & clicked=c_funloc(help_del))

       call hl_gtk_box_pack(hbox, hquit)

       call gtk_widget_show_all(help_window)

    end if

    call gtk_widget_grab_focus(fentry)
    call gtk_editable_set_position(fentry, -1)   ! Put cursor at end

  end subroutine show_help

  subroutine help_del(widget, gdata) bind(c)
    ! Delete help window
    type(c_ptr), value :: widget, gdata

    call gtk_widget_destroy(help_window)
  end subroutine help_del


  subroutine about_rpn(widget, gdata) bind(c)
    ! Display an about dialogue
    type(c_ptr), value :: widget, gdata

    type(c_ptr) :: adialog
    integer(kind=c_int) :: response
    character(kind=c_char), dimension(:), allocatable, target :: au1
    type(c_ptr), dimension(2) :: authors

    call convert_f_string((/ "James Tappin" /), au1)
    authors(1) = c_loc(au1)
    authors(2) = C_NULL_PTR

    adialog = gtk_about_dialog_new()
    call gtk_window_set_transient_for(adialog, win)
    call gtk_about_dialog_set_program_name(adialog, "RPN Calculator"//C_NULL_CHAR)
    call gtk_about_dialog_set_license(adialog, "GNU GPL 3"//C_NULL_CHAR)
    call gtk_about_dialog_set_comments(adialog, &
         & "This RPN calculator is a demonstration"//c_new_line// &
         & "of the capabilities of Gtk-fortran."//c_new_line//c_new_line// &
         & "It is entirely written in Fortran 95/2003."//c_new_line// &
         & "It should work with both Gtk+-2.24 and 3.0"//c_null_char)
    call gtk_about_dialog_set_authors(adialog, authors)
    call gtk_about_dialog_set_website(adialog, &
         & "https://github.com/jtappin/RPNcalc/wiki"//C_NULL_CHAR)

    response = gtk_dialog_run(adialog)
    call gtk_widget_destroy(adialog)
  end subroutine about_rpn

  subroutine about_gtkfortran (widget, gdata )  bind(c)
    ! About Gtk Fortran info.
    type(c_ptr), value :: widget, gdata

    type(c_ptr) :: dialog
    integer(c_int) :: response_id
    character(kind=c_char), dimension(:), allocatable, target :: au1, au2, &
         & au3, au4, au5
    type(c_ptr), dimension(6) :: authors

    call convert_f_string((/ "Jerry DeLisle" /), au1)
    call convert_f_string((/ "Vincent Magnin" /), au2)
    call convert_f_string((/ "James Tappin" /), au3)
    call convert_f_string((/ "Jens Hunger" /), au4)
    call convert_f_string((/ "Kyle Horne"/), au5)
    authors(1) = c_loc(au1)
    authors(2) = c_loc(au2)
    authors(3) = c_loc(au3)
    authors(4) = c_loc(au4)
    authors(5) = c_loc(au5)
    authors(6) = C_NULL_PTR

    dialog = gtk_about_dialog_new()
    call gtk_window_set_transient_for(dialog, win)
    call gtk_about_dialog_set_program_name(dialog, "Gtk-fortran"//C_NULL_CHAR)
    call gtk_about_dialog_set_license(dialog, "GNU GPL 3"//C_NULL_CHAR)
    call gtk_about_dialog_set_comments(dialog, &
         & "The gtk-fortran project aims to offer scientists programmi&
         &ng in Fortran a cross-platform library to build Graphical Us&
         &er Interfaces (GUI)."//c_new_line// & 
         &" Gtk-fortran is a partial GTK+ / Fortran binding 100% writt&
         &en in Fortran, thanks to the ISO_C_BINDING module for intero&
         &perability between C and Fortran, which is a part of the For&
         &tran 2003 standard."//c_new_line// & 
         & " GTK+ is a free software cross-platform graphical library &
         &available for Linux, Unix, Windows and MacOs X."//C_NULL_CHAR) 
    call gtk_about_dialog_set_website(dialog, &
         & "https://github.com/jerryd/gtk-fortran/wiki"//C_NULL_CHAR)

    call gtk_about_dialog_set_authors(dialog, authors)
    response_id =  gtk_dialog_run(dialog)
    call gtk_widget_destroy(dialog)

    call gtk_widget_grab_focus(fentry)
    call gtk_editable_set_position(fentry, -1)   ! Put cursor at end

  end subroutine about_gtkfortran

  subroutine set_format_make(widget, gdata) bind(c)
    ! Dialog to set up the format for data display.
    type(c_ptr), value :: widget, gdata

    type(c_ptr) :: jb, jbb, junk
    integer(kind=c_int) :: issens

    fmt_window = hl_gtk_window_new("Set format"//c_null_char, above=TRUE, &
         & destroy=c_funloc(set_format_destroy), parent=win)

    jb = hl_gtk_box_new()
    call gtk_container_add(fmt_window, jb)

    jbb = hl_gtk_box_new(horizontal=TRUE)
    call hl_gtk_box_pack(jb, jbb)
    junk = gtk_label_new("Current format = "//trim(result_format)//c_null_char)
    call hl_gtk_box_pack(jbb, junk, expand=FALSE)

    jbb = hl_gtk_box_new(horizontal=TRUE)
    call hl_gtk_box_pack(jb, jbb)
    junk = gtk_label_new("Format:"//c_null_char)
    call hl_gtk_box_pack(jbb, junk, expand=FALSE)
    fmt_choose = hl_gtk_combo_box_new(has_entry=TRUE, &
         & changed=c_funloc(set_format_type_cb), &
         & initial_choices=(/"Fixed   (F)", "Sci    (ES)", "Eng    (EN)", &
         & "General (G)", "Free    (*)"/), &
         & active = fmt_type, &
         & tooltip="Choose a format type or give a Fortran format code"//c_null_char)
    call hl_gtk_box_pack(jbb, fmt_choose)

    jbb = hl_gtk_box_new(horizontal=TRUE)
    call hl_gtk_box_pack(jb, jbb)
    junk = gtk_label_new("Precision:"//c_null_char)
    call hl_gtk_box_pack(jbb, junk, expand=FALSE)
    if (fmt_type >= 0 .and. fmt_type <= 3) then
       issens = TRUE
    else
       issens=FALSE
    end if
    fmt_precision = hl_gtk_spin_button_new(1, 30, initial_value=fmt_decimal, &
         & sensitive=issens, tooltip="Set the number of decimal places"//c_null_char)
    call hl_gtk_box_pack(jbb, fmt_precision)
    junk = gtk_label_new("Exponent:"//c_null_char)
    call hl_gtk_box_pack(jbb, junk, expand=FALSE)
    if (fmt_type >= 1 .and. fmt_type <= 3) then
       issens = TRUE
    else
       issens=FALSE
    end if
    fmt_expsize = hl_gtk_spin_button_new(1, 3, initial_value=fmt_expplaces,&
         & sensitive=issens, tooltip="Set the width of the exponent"//c_null_char)
    call hl_gtk_box_pack(jbb, fmt_expsize)

    jbb = hl_gtk_box_new(horizontal=TRUE)
    call hl_gtk_box_pack(jb, jbb)
    junk = hl_gtk_button_new("Apply"//c_null_char, clicked=c_funloc(set_format_cb))
    call hl_gtk_box_pack(jbb, junk)
    junk = hl_gtk_button_new("Cancel"//c_null_char, &
         & clicked=c_funloc(set_format_destroy))
    call hl_gtk_box_pack(jbb, junk)
    call gtk_widget_show_all(fmt_window)
  end subroutine set_format_make

  subroutine set_format_type_cb(widget, gdata) bind(c)
    ! Set the display format type
    type(c_ptr), value :: widget, gdata

    fmt_type = hl_gtk_combo_box_get_active(widget)

    select case(fmt_type)
    case(0)             ! Fixed
       call gtk_widget_set_sensitive(fmt_precision, TRUE)
       call gtk_widget_set_sensitive(fmt_expsize, FALSE)
    case(1,2,3)           ! Sci, eng, general
       call gtk_widget_set_sensitive(fmt_precision, TRUE)
       call gtk_widget_set_sensitive(fmt_expsize, TRUE)
    case(4,-1)          ! Free, explicit
       call gtk_widget_set_sensitive(fmt_precision, FALSE)
       call gtk_widget_set_sensitive(fmt_expsize, FALSE)
    end select
  end subroutine set_format_type_cb

  subroutine set_format_cb(widget, gdata) bind(c)
    ! Set the display format
    type(c_ptr), value :: widget, gdata

    integer(kind=c_int) :: nchars, dummy
    character(len=40) :: res_tmp
    integer :: idxc, idxo

    select case(fmt_type)
    case(0)                ! Fixed
       fmt_decimal = hl_gtk_spin_button_get_value(fmt_precision)
       write(result_format,"('(F0.',i0')')") fmt_decimal
    case(1)                ! Scientific
       fmt_decimal = hl_gtk_spin_button_get_value(fmt_precision)
       fmt_expplaces = hl_gtk_spin_button_get_value(fmt_expsize)
       nchars = 5+fmt_decimal+fmt_expplaces
       write(result_format, "('(ES',i0,'.',i0,'e',i0,')')") nchars, &
            & fmt_decimal, fmt_expplaces
    case(2)                ! Engineering
       fmt_decimal = hl_gtk_spin_button_get_value(fmt_precision)
       fmt_expplaces = hl_gtk_spin_button_get_value(fmt_expsize)
       nchars = 7+fmt_decimal+fmt_expplaces
       write(result_format, "('(EN',i0,'.',i0,'e',i0,')')") nchars, &
            & fmt_decimal, fmt_expplaces
    case(3)                ! General
       fmt_decimal = hl_gtk_spin_button_get_value(fmt_precision)
       fmt_expplaces = hl_gtk_spin_button_get_value(fmt_expsize)
       nchars = 5+fmt_decimal+fmt_expplaces
       write(result_format, "('(G',i0,'.',i0,'e',i0,')')") nchars, &
            & fmt_decimal, fmt_expplaces
    case(4)                ! List-directed
       result_format = ''
    case(-1)               ! An explicit format
       dummy = hl_gtk_combo_box_get_active(fmt_choose, ftext = res_tmp)
       if (res_tmp == "*") then
          result_format = ''
       else
          idxo = index(res_tmp, "(")
          idxc = index(res_tmp, ")", back=.true.)
          if (idxc /= len_trim(res_tmp)) res_tmp = trim(res_tmp)//")"
          if (idxo /= 1) res_tmp="("//res_tmp
          result_format=res_tmp
       end if
    end select

    call gtk_widget_destroy(fmt_window)

    call gtk_widget_grab_focus(fentry)
    call gtk_editable_set_position(fentry, -1)   ! Put cursor at end

  end subroutine set_format_cb

  subroutine set_format_destroy(widget, gdata) bind(c)
    ! Don't set the display format
    type(c_ptr), value :: widget, gdata

    call gtk_widget_destroy(fmt_window)

    call gtk_widget_grab_focus(fentry)
    call gtk_editable_set_position(fentry, -1)   ! Put cursor at end

  end subroutine set_format_destroy

  subroutine set_stats(widget, gdata) bind(c)
    ! Compute stats of the stack.
    type(c_ptr), value :: widget, gdata

    dynamic_stats = (gtk_toggle_button_get_active(widget) == TRUE)
    if (dynamic_stats) call stack_stats(0._c_double, initialize=.true.)

    call gtk_widget_grab_focus(fentry)
    call gtk_editable_set_position(fentry, -1)   ! Put cursor at end

  end subroutine set_stats

  subroutine statsel(widget, gdata) bind(c)
    ! Copy stats to the stack.
    type(c_ptr), value :: widget, gdata

    integer(kind=c_int) :: count, i
    integer(kind=c_int), dimension(:), allocatable :: sellist
    real(kind=c_double) :: x

    count = hl_gtk_listn_get_selections(fstats, sellist)
    if (count > 0) then
       do i = 1, count
          call hl_gtk_listn_get_cell(fstats, sellist(i), 1, dvalue=x)
          call push_stack(x)
       end do
       deallocate(sellist)
    end if

    call gtk_widget_grab_focus(fentry)
    call gtk_editable_set_position(fentry, -1)   ! Put cursor at end

  end subroutine statsel

  subroutine set_dms_hms(widget, gdata) bind(c)
    ! Set format of degrees or hours minutes seconds display.
    type(c_ptr), value :: widget, gdata
    
    dms_hms = c_f_logical(gtk_check_menu_item_get_active(widget))
    if (dms_hms) then
       call gtk_menu_item_set_label(khms, "DMS"//c_null_char)
    else
       call gtk_menu_item_set_label(khms, "HMS"//c_null_char)
    end if
  end subroutine set_dms_hms

  subroutine add_remove_registers(widget, gdata) bind(c)
    ! Add or remove registers according to the setting of the register count.
    type(c_ptr), value :: widget, gdata

    integer(kind=c_int) :: nreg, nsel
    integer(kind=c_int) :: i
    integer(kind=c_int), dimension(:), allocatable :: selected
    
    ! Since any valid INTEGER can be represented exactly by any double,
    ! we don't need to worry about using nint etc.

    nreg = int(hl_gtk_spin_button_get_value(widget))

    if (nreg > maxreg+1) then
       do i = maxreg+1, nreg-1
          call hl_gtk_listn_ins(fmemory)   ! Default is append
          call hl_gtk_listn_set_cell(fmemory, i, 0, ivalue=i)
          call hl_gtk_listn_set_cell(fmemory, i, 1, dvalue=0._c_double)
       end do
    else if (nreg < maxreg+1) then
       nsel = hl_gtk_listn_get_selections(fmemory, selected)
       if (nsel > 0) then
          if (any(selected >= nreg)) then
             call hl_gtk_listn_set_selection(fmemory)
             mem_selected = -1
          end if
       end if
       do i = maxreg, nreg, -1
          call hl_gtk_listn_rem(fmemory, i)
       end do
    end if
    maxreg = nreg-1
  end subroutine add_remove_registers

end module handlers
